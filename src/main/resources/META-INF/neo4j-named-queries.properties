DataResource.queryById=\
    MATCH (p:Party)-[:POSTED]->(d:DataResource)<-[:RESOURCE]-(rs) \
    where id(d)= {0} \
    return \
    d{ \
        id: id(d), \
        .*, \
        rp_partyId:p.partyId, \
        source: rs \
    }
DataResource.queryForHomePageAllFeed=\
    MATCH (d:DataResource) \
    where d.status='ACTIVE' \
    with d order by d.createdDate desc \
    RETURN  d{ \
        id:id(d), \
        .*, \
        rp_partyId: d.createdBy, \
        resource: head([(d)<-[:RESOURCE]-(rs)| properties(rs)]), \
        reactions: { \
            noReaction: size([(d)<-[:TO]-(ra:Reaction)| ra]), \
            types:[(d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE'| ra.type] \
            }, \
        noComment: size([(d)<-[:ON]-(cm:Comment) where cm.status='ACTIVE' | cm]), \
        place: head([(d)-[:CHECKED_IN]->(pla:Place)|properties(pla)]), \
        shared: head([(d)<-[:SHARED]-(s:Share)|properties(s)]) \
    } \
    skip {0} limit {1}
Reaction.inactiveByPartyAndResourceId=\
    match (p:Party) where p.partyId={0} \
    match (d) where ID(d)={1} \
    match (p)-[:REACTED]->(r: Reaction)-[:TO]->(d) \
    set r.status='INACTIVE', r.inactiveDate=timestamp()
Reaction.queryByPartyAndSourceId=\
    match (p:Party) where p.partyId={0} \
    match (d) where ID(d)={1} \
    match (p)-[:REACTED]->(r: Reaction)-[:TO]->(d) \
    return r
Reaction.findActiveByIdAndPartyId=\
    match (r:Reaction) where id(r)={0} and r.status='ACTIVE' \
    match (p: Party) where p.partyId={1} \
    match (p)-[:REACTED]-(r) \
    return r
CommentEntity.queryByIdAndOwner=\
    match (c:Comment) where ID(c)={0} \
    match (p:Party) where p.partyId={1}  \
    match (p)-[:COMMENTED]->(c)  \
    with distinct c return c
CommentEntity.queryByIdAndResourceOwner=\
    match (c:Comment) where ID(c)={0}  \
    match (p:Party) where p.partyId={1} \
    match (p)-[:POSTED]->(d:DataResource)<-[:ON*1..2]-(c) \
    return c
CommentEntity.queryForDetail=\
    match (c:Comment) where id(c)={0} \
    optional match (c)<-[:ON]-(cc:Comment) where cc.status='ACTIVE' \
    with c, cc \
    order by cc.createdDate asc \
    return { \
        id:id(c), \g
        text:c.text, \
        hasEdit:c.hasEdit, \
        editedDate:c.editedDate, \
        createdDate:c.createdDate, \
        createdBy:c.createdBy, \
        lastModifiedDate:c.lastModifiedDate, \
        lastModifiedBy:c.lastModifiedBy, \
        status:c.status, \
        inactiveDate:c.inactiveDate, \
        thread: collect( cc{ \
            id:id(cc), \
            .*, \
            rp_partyId: head([(cc)<-[:COMMENTED]-(cp:Party) | cp.partyId]), \
            noReaction: size([(cc)<-[:TO]-(r_cc:Reaction) where r_cc.status='ACTIVE'|r_cc ]), \
            hasReacted: head([(cc)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId=0 and sra.status='ACTIVE'| sra.type]) \
            }), \
        noReply: count(cc), \
        noReaction: size([ \
            (c)<-[:ON*0..2]-(ac:Comment)<-[:TO]-(r_ac:Reaction) where ac.status='ACTIVE' and r_ac.status='ACTIVE'|r_ac \
        ]), \
        hasReacted: head([(c)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId=0 and sra.status='ACTIVE'| sra.type]), \
        rp_partyId: head([(c)<-[:COMMENTED]-(cp:Party) | cp.partyId]) \
    }
CommentEntity.queryPageByResourceId=\
    match (drs)<-[:ON]-(c:Comment) where id(drs)={0} and c.status='ACTIVE' \
    optional match (c)<-[:ON]-(cc:Comment) where cc.status='ACTIVE' \
    with c,cc order by c.createdDate asc,  cc.createdDate desc \
    return { \
        id:id(c), \
        text:c.text, \
        hasEdit:c.hasEdit, \
        editedDate:c.editedDate, \
        createdDate:c.createdDate, \
        createdBy:c.createdBy, \
        lastModifiedDate:c.lastModifiedDate, \
        lastModifiedBy:c.lastModifiedBy, \
        status:c.status, \
        inactiveDate:c.inactiveDate, \
        rp_partyId: head([(c)<-[:COMMENTED]-(cp:Party) | cp.partyId]), \
        hasReacted: head([(c)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId=0 and sra.status='ACTIVE'| sra.type]), \
        lastComment: head(collect( cc{ \
            id:id(cc), \
            .*, \
            rp_partyId: head([(cc)<-[:COMMENTED]-(cp:Party) | cp.partyId]), \
            noReaction: size([(cc)<-[:TO]-(r_cc:Reaction) where r_cc.status='ACTIVE'|r_cc ]), \
            hasReacted: head([(cc)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId=0 and sra.status='ACTIVE'| sra.type]) \
        })), \
        noReply: count(cc), \
        noReaction: size([(c)<-[:ON*0..2]-(ac:Comment)<-[:TO]-(r_ac:Reaction) where ac.status='ACTIVE' and r_ac.status='ACTIVE'|r_ac]) \
    } as c \
    skip {1} limit {2}
CommentEntity.queryCoutByResourceId=\
    match (drs)<-[:ON]-(c:Comment) where id(drs)={0} and c.status='ACTIVE' \
    return count(c)
DataResource.countHomePageAsNormal=\
    match (p:Party) where p.partyId={currentPartyId} \
    match (p)-[:FOLLOWED]->(op:Party)-[rps:POSTED|HAS_POSTED]->(d:DataResource) where d.status='ACTIVE' \
    OPTIONAL MATCH (d)-[:POLICY]->(pol:DataResourcePolicy) \
    WHERE ( \
        pol is null or (pol.type='PUBLIC') \
        or (pol.type='CONNECTION' and ( ({currentPartyId} in pol.connInclude) or (not {currentPartyId} in pol.connExclude))) \
        or (pol.type='GROUP' and (({currentPartyId} in pol.connInclude) or(not {currentPartyId} in pol.groupExclude)) ) \
    ) \
    return count(d)
DataResource.queryHomePageAsNormal=\
    match (p:Party) where p.partyId={currentPartyId} \
    match (p)-[:FOLLOWED]->(op:Party)-[rps:POSTED|HAS_POSTED]->(d:DataResource) where d.status='ACTIVE' \
    OPTIONAL MATCH (d)-[:POLICY]->(pol:DataResourcePolicy) \
    WHERE ( \
        pol is null or (pol.type='PUBLIC') \
        or (pol.type='CONNECTION' and ( ({currentPartyId} in pol.connInclude) or (not {currentPartyId} in pol.connExclude))) \
        or (pol.type='GROUP' and (({currentPartyId} in pol.connInclude) or(not {currentPartyId} in pol.groupExclude)) ) \
    ) \
    return d{ \
        id:id(d), \
        .*, \
        rp_partyId: p.partyId, \
        relationship: rps{id:id(rps), type: type(rps), .*}, \
        resource: head([(d)<-[:RESOURCE]-(rs)| properties(rs)]), \
        reactions: { \
            types:   [(d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' | ra.type] , \
            noReaction: size([(d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' | ra]) \
        }, \
        policyType: coalesce(pol.type, 'PUBLIC'), \
        hasReacted: head([(d)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId={currentPartyId} and sra.status='ACTIVE'| sra.type]), \
        noComment: size([(d)<-[:ON*1..2]-(cm:Comment) where cm.status='ACTIVE' |cm]), \
        place: head([(d)-[:CHECKED_IN]->(pla:Place)|properties(pla)]), \
        tags: [(tp:Party)-[:TAGGED]->(d)| tp.partyId] \
    } \
    order by d.createdDate desc \
    skip {offset} limit {pageSize}
#DataResource.countHomePageAsNew=\
#    MATCH (p:Party) where p.partyId in {similarPartyIds} \
#    MATCH (p)-[r:POSTED|HAS_POSTED]->(d:DataResource {status:'ACTIVE'}) \
#    OPTIONAL MATCH (d)-[:POLICY]->(pol:DataResourcePolicy) \
#    WHERE ( \
#        pol is null or (pol.type='PUBLIC') \
#        or (pol.type='CONNECTION' and ( ({currentPartyId} in pol.connInclude) or (not {currentPartyId} in pol.connExclude))) \
#        or (pol.type='GROUP' and (({currentPartyId} in pol.connInclude) or(not {currentPartyId} in pol.groupExclude)) ) \
#    ) \
#    return count(d)
DataResource.queryHomePageAsNew=\
    MATCH (p:Party) where p.partyId in {similarPartyIds} \
    MATCH (p)-[r:POSTED|HAS_POSTED]->(d:DataResource {status:'ACTIVE'}) \
    OPTIONAL MATCH (d)-[:POLICY]->(pol:DataResourcePolicy) \
    WHERE ( \
        pol is null or (pol.type='PUBLIC') \
        or (pol.type='CONNECTION' and ( ({currentPartyId} in pol.connInclude) or (not {currentPartyId} in pol.connExclude))) \
        or (pol.type='GROUP' and (({currentPartyId} in pol.connInclude) or(not {currentPartyId} in pol.groupExclude)) ) \
    ) \
    return d{ \
        id:id(d), \
        .*, \
        rp_partyId: p.partyId, \
        relationship: r{id:id(r), type: type(r), .*}, \
        resource: head([(d)<-[:RESOURCE]-(rs)| properties(rs)]), \
        reactions: { \
            noReaction: size([(d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' | ra]), \
            types:   [(d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' | ra.type]  \
        }, \
        policyType: coalesce(pol.type, 'PUBLIC'), \
        hasReacted: head([(d)<-[:TO]-(sra:Reaction)<-[:REACTED]-(srp:Party) where srp.partyId={currentPartyId} and sra.status='ACTIVE'| sra.type]), \
        noComment: size([(d)<-[:ON*1..2]-(cm:Comment) where cm.status='ACTIVE' |cm]), \
        place: head([(d)-[:CHECKED_IN]->(pla:Place)|properties(pla)]), \
        tags: [(tp:Party)-[:TAGGED]->(d)| tp.partyId] \
    } \
    order by d.createdDate desc \
    skip {offset} limit {pageSize}
Reaction.countReactionsBySourceId=\ 
    match (d:DataResource) where id(d) = {0} \
    match (d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' \
    return count(ra)
Reaction.queryReactionsBySourceId=\
    match (d:DataResource) where id(d) = {0} \
    match (d)<-[:TO]-(ra:Reaction) where ra.status='ACTIVE' \
    with ra order by ra.createdDate desc \
    return ra{ \
        id:id(ra), \
        .*, \
        rp_partyId: head([(ra)<-[:REACTED]-(p:Party)|p.partyId]) \
    } \
    skip {1} limit {2}
Reaction.statisticBySourceId=\
    match (d) where id(d) ={0} \
    match (d)-[:TO]-(ra:Reaction) \
    with ra, ra.type as ty \
    return distinct ty as type, count(ty) as no
DataResource.queryShared=\
    match (d:DataResource) where id(d) in {0} \
    return d{ \
        id:id(d), \
        .*, \
        resource:head([(d)<-[:RESOURCE]-(rs)| properties(rs)]), \
        rp_partyId: head([(p:Party)-[:POSTED]->(d)|p.partyId]) \
    }
Share.queryByDataRsId=\
    match (s:Share)-[:SHARED]->(d:DataResource) \
    where id(d)= {0} \
    return s
Announcement.queryActiveByTime=\
    match (a:Announcement) \
    where a.status='ACTIVE' and a.fromDate<$time and a.toDate>$time \
    return a{ \
        id:id(a) \
        ,.* \
    }
ConnectedRel.queryExistsConnected=\
    match (p1:Party) where p1.partyId=$connectorId \
    match (p2:Party) where p2.partyId=$connectedId \
    return exists((p1)-[:CONNECTED]-(p2)) as result
PartyEntity.deleteFollowedOrConnectedRelBetween=\
    match (p1:Party) where p1.partyId=$p1Id \
    match (p2:Party) where p2.partyId=$p2Id \
    match (p1)-[r:CONNECTED|FOLLOWED]-(p2) \
    delete r \
    return count(r)
BlockedRel.queryBlockedRelBetween=\
    match (p1:Party) where p1.partyId=$blockerId \
    match (p2:Party) where p2.partyId=$blockedId \
    match (p1)-[r:BLOCKED]-(p2) \
    return r,p1,p2
ReportedRel.queryReportedRelBetween=\
    match (p1:Party) where p1.partyId=$reporterId \
    match (p2:Party) where p2.partyId=$reportedId \
    match (p1)-[r:REPORTED]-(p2) \
    return r,p1,p2
